%% s využitím syntaktického analyzátoru SET vytvořte program, který bude převádět texty mezi oběma formami. Zohledněte gramaticko-syntaktické jevy spojené s každou z vyprávěcích forem (osoba slovesných tvarů, osobní a přivlastňovací zájmena, spojky kdyby a aby, přímá řeč, rezoluce anafor).
In this chapter, I describe the implementation of the tool \emph{RephrasErIch} which converts a given text between first-person and third-person narratives, and I present other tools that I used in the implementation.

\section{Tools used} \label{sec:external-tools}

\subsection{SET}

As mentioned before, syntactic analysis is needed for narrative conversion. From the existing Czech syntactic analyzers, I decided to use analyzer \emph{SET}. The main reason why I chose this analyzer is my previous experience with using this tool and its ability to produce dependency trees.

SET is implemented in the Python programming language. Although RephrasErIch is also written in this programming language, it would be challenging to integrate the tools since SET is implemented in the old Python version, Python 2. For this reason, the tools communicate with each other through the command line. The communication is handled by a class \texttt{Syn}.
TODO

\subsection{Majka}

\emph{Majka} \cite{majka} provides a morphological analysis. The tool is able to:
\begin{itemize}
	\item assign lemmas and tags to words
	\item generate all correct word forms and tags for a given lemma
	\item generate a word form according to a given lemma and tag
\end{itemize}

RephrasErIch uses Majka directly, mainly for the third use case. Majka is written in C language. Therefore my tool contains a class \texttt{morph} which calls Majka binary code from the command line and processes the output.

\subsection{Desamb}

\emph{Desamb} is a morphological disambiguator using Majka as a morphological tagger. Majka finds the set of lemmas and tags to the given word, then Desamb chooses the most appropriate lemma and tag. Unlike Majka, results also depend on the word context, which is essential for correct tagging. TODO

In my implementation, I use Desamb to generate an input for syntactic analysis.

\subsection{Aara}

The last task that I use external tools for is \emph{anaphora resolution}. Anaphora resolution is a problem of resolving what a pronoun refers to sentence part mentioned earlier in the discourse. For instance, the resolution of a sentence: \emph{Jacob saw his dad in the school} would tell us that \emph{his} refers to \emph{Jacob}.
%% to do: cite

There are few tools for Czech anaphora resolution, and the existing ones do not perform very well. Still, anaphora resolution is required for third-to-first conversion. Thus I decided to use a tool \emph{Aara}. Usage of Aara is provided by a class \texttt{Anaph}, which is run from a command line for the same reasons as SET.

\section{Class structure}

The tool is implemented as a Python library. The library consists of six important classes. It is easier to identify at which linguistic level the problem occurred by decomposing the processes into different levels. It allows parts of the text to be easily put back together, and I found the object representation to be a straightforward way of storing information from the various analyses. In this section, I briefly describe these main classes and their interactions.

\subsection{RephrasErIch}

\texttt{RephrasErIch} is the highest class of the implementation which represents the tool itself. It keeps three attributes:

\begin{itemize}
	\item \texttt{from\_form} -- the narrative form to convert from
	\item \texttt{protg} -- a story protagonist
	\item \texttt{text} -- a given text, an instance of a class \texttt{Text}
\end{itemize}

The essential method is a method \texttt{rephrase} which creates an object representation of the given text and starts the narrative conversion.

\subsection{Text}

Class \texttt{Text} is an object representation of text data to be converted. When constructed, the text is divided into paragraphs. The paragraphs are being kept as a list of \texttt{Paragraph} objects.

\subsection{Paragraph}

Just as text is divided into paragraphs, a paragraph is divided into sentences. Besides the division, the class \texttt{Paragraph} is responsible for direct speech preprocessing and anaphora resolution.

After the direct speech has been processed and the anaphors resolved, the \texttt{create\_sentences} method is called. This method segments the paragraph and creates a list of \texttt{Sentence} objects.

\subsection{Sentence}

Class \texttt{Sentence} takes a text version of a given sentence and a dictionary of anaphors related to the sentence. At the sentence level, the syntactic analysis is performed. A sentence is represented as a dependency tree generated by \texttt{SET} and \texttt{Desamb}. Every node of this tree (usually a word) is an instance of a class \texttt{Word}.

\subsection{Word}

The basic unit of this recursive class structure is class \texttt{Word}. After performing the higher-level analyses, the word now has all the information needed to be converted: protagonist, anaphors, direct speech, position in the sentence tree, word's lemma, etc.

At the word level, finally, the narrative conversion is being done. The word generates a new form as it applies the earlier proposed rules.

\subsection{Protagonist}

The last important class I have decided to mention is the \texttt{Protagonist}. This class stands out somewhat from the whole class structure, but at the same time, it is passed by across all the other classes. It keeps the information about the story protagonist, which is essential to the conversion process.

\section{Conversion Rules Implementation}

This section describes the implementation of the rules introduced in Chapter \ref{chap:navrh-pravidel}.

For clarity, the implementation of the rules is divided in two files (\texttt{erich\_rules.py} and \texttt{icher\_rules.py} \footnote{The terms \emph{ich} and \emph{er} come from German, where \emph{ich} means \emph{I} and \emph{er} means \emph{he}. These terms are also used in Czech to refer to first-person and third-person narratives.})  according to the conversion direction. Each rule is implemented as a Python function. These functions are called inside methods of the \texttt{Word} class. (\texttt{\emph{word}.\_ich\_to\_er()}, \texttt{\emph{word}.\_er\_to\_ich()})
As can be seen in Chapter \ref{chap:navrh-pravidel}, each rule starts with an assumption (e.g. as \emph{Word is Auxiliary verb}). These assumptions are represented by conditions inside the \texttt{Word} methods. If a condition is evaluated as true, the relevant rule is called, and the return value is set as the new form of the word.
Thus, there are two steps needed to add a new rule to the implementation:

\begin{enumerate}
	\item Define the rule as a function in \texttt{icher\_rules.py}/\texttt{erich\_rules.py}.
	\item Add the initial assumption as a condition to the corresponding \texttt{Word} method and call the rule function in that block.
\end{enumerate}

\subsection*{Notes to the implementation of the rules}

I note that not all of the proposed rules could be implemented. The tool does not include a rule replacing possessive pronouns when converting from third-person to the first-person narrative. This is because of the limitations set by Aara, which is currently unable to assign references to possessive pronouns.

\section{How to Use the Tool}

Currently, RephrasErIch use is limited by several factors:

\begin{itemize}
	\item RephrasErIch works only on Unix due to the command line execution of some programs.
	\item The use of the tool assumes running on the NLP Centre of the Faculty of Informatics machines, which have access to the center's other projects. \footnote{More information can be found at \href{https://nlp.fi.muni.cz}{nlp.fi.muni.cz}} Otherwise, it would be necessary to install the external tools mentioned in Section \ref{sec:external-tools}.
\end{itemize}

I illustrate the usage of the tool in the following code, which should be placed in the \texttt{main.py} file.
\newline

\begin{lstlisting}[language=Python]
import sys

sys.path.append('./enums/')  # enumeration classes, such as Forms
sys.path.append('./classes/')  # the six classes mentioned in section 6.2
sys.path.append('./tools/')  # classes handling communication with external tools

from RephrasErIch import RephrasErIch
from Forms import Form

text = "Petr chce, aby Anna plakala."

rerich = RephrasErIch(Form.ER)
rerich.create_protagonist("Anna")
rephrased_text = rerich.rephrase(text)
\end{lstlisting}


As can be seen, five main steps are needed to convert a text:

\begin{enumerate}
	\item Add all the necessary paths to subdirectories. In the example, I use a module \texttt{sys} to do so.
	\item Import the classes being used.
	\item Initialize an object (\texttt{rerich}) as an instance of the class \texttt{RephrasErIch} with declared original narrative form of the text.
	\item Create an instance of the class \texttt{Protagonist}.
	\item Call the method \texttt{rephrase(text: str)} on \texttt{rerich} with the text to rephrase as an argument.
\end{enumerate}

When the content of the variable after the program has finished is printed, the output might be the following:
\newline
\begin{lstlisting}[language=bash]
> Petr chce, abych plakala.
\end{lstlisting}

