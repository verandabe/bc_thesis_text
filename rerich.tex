%% s využitím syntaktického analyzátoru SET vytvořte program, který bude převádět texty mezi oběma formami. Zohledněte gramaticko-syntaktické jevy spojené s každou z vyprávěcích forem (osoba slovesných tvarů, osobní a přivlastňovací zájmena, spojky kdyby a aby, přímá řeč, rezoluce anafor).
In this chapter, I describe the implementation of the tool \emph{RephrasErIch} which converts a given text between first-person and third-person narratives, and I present other tools that I used in the implementation.

\section{Tools used}

\subsection{SET}

As mentioned before, syntactic analysis is needed for narrative conversion. From the existing Czech syntactic analyzers, I decided to use analyzer \emph{SET}. The main reason why I chose this analyzer is my previous experience with using this tool and its ability to produce dependency trees.

SET is implemented in the Python programming language. Although RephrasErIch is also written in this programming language, it would be challenging to integrate the tools since SET is implemented in the old Python version, Python 2. For this reason, the tools communicate with each other through the command line. The communication is handled by a class \texttt{Syn}.

\subsection{Majka}

\emph{Majka} \cite{majka} provides a morphological analysis. The tool is able to:
\begin{itemize}
	\item assign lemmas and tags to words
	\item generate all correct word forms and tags for a given lemma
	\item generate a word form according to a given lemma and tag
\end{itemize}

RephrasErIch uses Majka directly, mainly for the third use case. Majka is written in C language. Therefore my tool contains a class \texttt{morph} which calls Majka's binary code from a command line and processes the output.

\subsection{Desamb}

\emph{Desamb} is a morphological disambiguator using Majka as a morphological tagger. Majka finds the set of lemmas and tags to the given word, then Desamb chooses the most appropriate lemma and tag. Unlike Majka, results also depend on the word's context, essential for correct tagging.

In my implementation, I use Desamb to generate an input for syntactic analysis.

\subsection{Aara}

The last task that I use external tools for is \emph{anaphora resolution}. Anaphora resolution is a problem of resolving what a pronoun refers to earlier or later in the discourse. For instance, the resolution of a sentence: \emph{Jacob saw his dad in the school} would tell us that \emph{his} refers to \emph{Jacob}.
%% to do: cite

There are few tools for Czech anaphora resolution, and the existing ones do not perform very well. Still, anaphora resolution is required for third-to-first conversion. Thus I decided to use a tool \emph{Aara}. Usage of Aara is provided by a class \texttt{Anaph}, which is run from a command line for the same reasons as SET.

\section{Class structure}

The tool is implemented as a Python library. The library consists of six important classes. In this section, I briefly describe these main classes. Next, I show how they interact in an example input.

\subsection{RephrasErIch}

\texttt{RephrasErIch} is the highest class of the implementation which represents the tool itself. It keeps three attributes:

\begin{itemize}
	\item \texttt{from\_form} -- the narrative form we would like to convert from
	\item \texttt{protg} -- a story protagonist
	\item \texttt{text} -- a given text, an instance of a class \texttt{Text}
\end{itemize}

The essential method is a method \texttt{rephrase} which creates an object representation of the given text and it starts the narrative conversion.

\subsection{Text}

Class \texttt{Text} is an object representation of text data to be converted. When constructed, the text is divided into paragraphs. The paragraphs are being kept as a list of \texttt{Paragraph} objects.

\subsection{Paragraph}

Just as text is divided into paragraphs, a paragraph is divided into sentences. Besides the division, the class \texttt{Paragraph} is responsible for direct speech preprocessing and anaphora resolution.

After the direct speech has been processed and the anaphors resolved, the \texttt{create\_sentences} method is called. This method segments the paragraph and creates a list of \texttt{Sentence} objects.

\subsection{Sentence}

Class \texttt{Sentence} takes a text version of a given sentence and a dictionary of anaphors related to the sentence. At the sentence level, the syntactic analysis is performed. A sentence is represented as a dependency tree generated by \texttt{SET} and \texttt{Desamb}. Every node of this tree (usually a word) is an instance of a class \texttt{Word}.

\subsection{Word}

The basic unit of this recursive class structure is class \texttt{Word}. After performing the higher-level analyses, the word now has all the information needed to be converted: protagonist, anaphors, direct speech, position in the sentence tree, word's lemma, etc.

At the word level, finally, the narrative conversion is being done. The word generates a new form as it applies the earlier proposed rules.

\subsection{Protagonist}

The last important class I have decided to mention is the \texttt{Protagonist}. This class stands out somewhat from the whole class structure, but at the same time, it is passed by across all the other classes. It keeps the information about the story protagonist, which is essential to the conversion process.

